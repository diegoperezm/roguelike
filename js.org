#+PROPERTY: header-args :results verbatim

* JS 

** interface 
#+NAME: interface
#+BEGIN_SRC js 
function interface(id, keyCode ) {
   let input = Object.assign({"id":id}, {"keyCode": keyCode}, {});
   inputHandler(input); 
 }
#+END_SRC




** canvas    

#+NAME: canvas 
#+BEGIN_SRC js
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
#+END_SRC


** map 

#+NAME: map
#+BEGIN_SRC js
/*
  0 : walkable
  1 : not walkable (a wall)
 */ 

// prettier-ignore
var map = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

#+END_SRC




** worldData 

#+NAME: worldData 
#+BEGIN_SRC js
let worldData = [];
#+END_SRC




** objects

#+NAME: objects
#+BEGIN_SRC js
const objects = {
    "wall": {
      id: 1,
      color: "rgba(200, 200, 200, 1)",
      pos: {
	x: 0,
	y: 0
      },
    },
    "monster" : {
     id: "monster",
     type: "monster",
     color: "rgba(0,0,255,1)",
     pos: {
       x: 0, 
       y: 0
     },
     width: 10,
     height: 10,
     HP: 1
    },
    "player": 
    {
    id: "player",
    type: "player",
    color: "rgba(255,0,0,1)",
    pos: {
      x: 6,
      y: 5
    },
    width: 10,
    height: 10,
    HP: 100
  }
};
#+END_SRC





** fsm

#+NAME: fsm 
#+BEGIN_SRC js 
const { Machine, actions }  = window.XState;
const { interpret }         = window.XStateInterpreter;
const { assign , log}           = actions; 

const  fsm =  Machine (
{
 id: "fsmOne", 

 initial: "idle",

 context: {
  nextMove: {
    x: 6, y: 5
  },
  nextAttack:[], 
  isAlive: ''
 },

  states: {

   idle: {
    on: {
     LEFT: { 
         target:  "collisiondetection"
	   },

     UP: { 
         target:  "collisiondetection"
	   },

     RIGHT: { 
         target:  "collisiondetection"
	   },

     DOWN: { 
         target:  "collisiondetection",
	 }
     },

    onExit: ['log', 'nextMoveFn']
   
   },

 collisiondetection: {
   onEntry: ['log'],
   invoke: {
     src: (ctx, event) => (callback, onEvent) => {
      const result = collisionDetection(ctx, event);
      callback(result);
   }
 },
   on: {
    WALK: {
       target: 'moving', 
       actions: 'log'
     },
    WALL: {
      target: 'idle', 
      actions: 'log'
    },
    MONSTER: {
      target: 'isAlive',
      actions: 'log'
   } 
   }  
  },
  
  moving: {
   invoke: {
     src: (ctx, event) => (callback, onEvent) => {
      callback('WALK');
   }
 },
  on: {
    WALK: {
       target: 'idle',  actions: ['log', 'updater']
    }
   },
  },

 isAlive: {
  invoke: {
    src: (ctx, event) => (callback, onEvent) => {
      const isAliveResult = isAlive();
      callback(isAliveResult);
    }
  },

  on: {
    YES: 
    {
      target: 'attacking', 
     actions: 'nextAttackFn' 
    },
    NO: {target: 'remove'}
  }
 
 },
 
 attacking: {
   on: {
       ATTACK: { 
       target: 'isAlive'
         } 
       },
     onExit: 'updater'
   },

 remove: {
  invoke: {
   src: (ctx,event) => (callback, onEvent) =>{
     callback('REMOVE');  
   }
  },
   on: {
     REMOVE: {
        target: 'idle'
      }
     },
     onExit: 'updater'
    },
  }
  },
  {
   actions: {
    nextMoveFn:   assign({  nextMove: (ctx, event) => move(ctx, event)}),
    nextAttackFn: assign({nextAttack: (ctx, event) => attackEnemy(ctx, event)}),
    attackEnemy,
    updater,
    move,
    log: log( (ctx,event) => 
    `
    nextMove:
      x:  ${ctx.nextMove.x}
      y:  ${ctx.nextMove.y}
     isAlive: ${ctx.isAlive}
      action: ${ctx.action}
    event: ${event.type}`, 'label')
   },

  }); 




const fsmService = interpret(fsm).onTransition( state => {
  console.log("fsmService state.value ", state.value);
});



#+END_SRC


** isalive 

#+NAME: isalive  
#+BEGIN_SRC js
function isAlive() {
 let index = worldData.findIndex(elem => elem.HP <= 0 ); 
 console.log('calling fn isAlive ' , worldData[index], index);

  if( index === -1) {
     console.log("yes");
      return 'YES';
  } else {
    console.log("no");
     return 'NO';
  } 
 }
#+END_SRC


** collisiondetection
#+NAME: collisiondetection
#+BEGIN_SRC js
function collisionDetection(extendedState, event) {

console.log('COLLISIONdETECTION fn', extendedState, event);


let nextMove = extendedState.nextMove;


let x = nextMove.x; 
let y = nextMove.y; 

if( map[y][x] === 0) {

 return "WALK";

 } else if ( map[y][x] === 1) {

 return "WALL";

 } else if (typeof map[y][x] === 'string') {

 return "MONSTER";

 }

}
#+END_SRC


** move
#+NAME: move
#+BEGIN_SRC js
function move (extendedState, event) {

console.log('move fn ', extendedState, event );

let direction = event.type;

let x;
let y;

let indexId = worldData.findIndex( element => element.id === "player" );

switch(direction) {

  case "LEFT":
   x = worldData[indexId].pos.x - 1;
   y = worldData[indexId].pos.y;
   break;

  case "UP":
   x = worldData[indexId].pos.x;    
   y = worldData[indexId].pos.y - 1;
   break;


  case "RIGHT":
   x = worldData[indexId].pos.x + 1;
   y = worldData[indexId].pos.y;
   break;

  case "DOWN":
   x = worldData[indexId].pos.x;    
   y = worldData[indexId].pos.y + 1;
   break;

}

return {x:x,y:y};

}
#+END_SRC


** attackenemy
#+NAME: attackenemy
#+BEGIN_SRC js 
function attackEnemy (extendedState) { 

console.log('attackEnemy', extendedState.nextAttack);
 let playerIndex =  worldData.findIndex(elem => elem.id === 'player'); 
 let player = worldData[playerIndex];
 let playerHP =  player.HP;

 let x = extendedState.nextMove.x;
 let y = extendedState.nextMove.y;

 let monsterIndex = worldData.findIndex(elem => elem.pos.x === x &&  elem.pos.y === y); 
 let monster = worldData[monsterIndex];
 let monsterHP = monster.HP;

 playerHP  -= 1; 
 monsterHP -= 1;

 let newStatePlayer  =   Object.assign({}, player, {"HP": playerHP}); 
 let newStateMonster =   Object.assign({}, monster,{"HP": monsterHP});

 return [newStatePlayer, newStateMonster];

};
#+END_SRC


** updater 

#+NAME: updater
#+BEGIN_SRC  js
function updater(extendedState, event) {


 let action = event.type;

console.log("updater fn ",extendedState, event, action);

  switch(action) {

   case "WALK":
      let index = worldData.findIndex(elem => elem.id === 'player');
      worldData[index].pos.x = extendedState.nextMove.x;
      worldData[index].pos.y = extendedState.nextMove.y;
      break;

    case "ATTACK":
      extendedState.nextAttack.forEach( function(elem) {
       let index = worldData.findIndex(ele => ele.id === elem.id);
	worldData[index] = elem;
      });
      console.log('updater case ATTACK ' , worldData);
      break;

    case "REMOVE":
      let indx = extendedState.nextAttack.findIndex(elem => elem.HP <= 0 ); 
      let arr = [];
      arr[0] = extendedState.nextAttack[indx];
      let newWorldData = differenceArray(worldData, arr);
      worldData = newWorldData; 
      monsterInfoRemove(arr[0]);
      break;
  }

  // clean map
  map.forEach(function(elem) {
    for (let i = 0; i < elem.length; i++) {
      if (elem[i] != 1) {
	// don't remove the walls
	elem[i] = 0;
      }
    }
  });

  // update map
  worldData.forEach(function(elem) {
    if (elem.id != 1 ) { 
   map[elem.pos.y][elem.pos.x] = elem.id;
   }
  });

  // draw map with the current state
  drawMap();

  // update player info with current state
  playerInfo();

  // update monster info with current state
  monsterInfoUpdate();

}
#+END_SRC


** inputhandler

#+NAME: inputhandler
#+BEGIN_SRC js 
function inputHandler(inputObj) {

let input;
let id = inputObj.id;

 switch (inputObj.keyCode) {

  case 37:
    input = "LEFT"; 
   break;

  case 72:
    input = "LEFT"; 
   break;
    
  case 38:
    input = "UP";
   break;

 
  case 75:
    input = "UP";
   break;

  case 39:
   input = "RIGHT";
   break;

  case 76:
   input = "RIGHT";
   break;

  case 40:
    input = "DOWN";
   break;
  
  case 74:
    input = "DOWN";
   break;
   
  case 88:
    input = "ATTACK";
   break;
  
} 

    fsmService.send(input);
}
#+END_SRC



** differencearray

#+NAME: differencearray
#+BEGIN_SRC js
function differenceArray (a, b) {
    return a.filter( function(elem) { return b.indexOf(elem) < 0;  });
}
#+END_SRC



** start
#+NAME: start
#+BEGIN_SRC js
function start() {

   
  // LISTENER
  document.addEventListener("keydown", _.throttle((keyDown) => interface("player", keyDown.keyCode), 100, {'trailing': false}));

  /* Add wall id to state.
     At the moment the walls are hardcoded (map) 
  */
  worldData.push(objects.wall);

  // Create monsters (no more than 12) 
  let monsters = createMonsters(8);

  // Add monsters to state
  monsters.forEach(function(elem) {
    worldData.push(elem);
  });

  // Add player to state
  worldData.push(objects.player);   

  // Add  player and monsters to map using state
  worldData.forEach(function(elem) {
    if (elem.id != 1) {
      map[elem.pos.y][elem.pos.x] = elem.id;
    }
  });

  drawMap();
  playerInfo();
  monsterInfoCreateDOM();
}
#+END_SRC


** playerinfo 
#+NAME: playerinfo
#+BEGIN_SRC  js
function playerInfo()  {

let playerIndex =  worldData.findIndex(elem => elem.id==="player"); 
let player = worldData[playerIndex];

let playerInfo = document.getElementById("playerInfo");
let playerId   = document.getElementById("playerId");
let playerPosX = document.getElementById("playerPosX");
let playerPosY = document.getElementById("playerPosY");
let playerHP   = document.getElementById("playerHP");

playerId.textContent   =   player.id;
playerPosX.textContent =   player.pos.x;
playerPosY.textContent =   player.pos.y;
playerHP.textContent   =   player.HP;
}
#+END_SRC





** allindxtypemonster 

#+NAME: allindxtypemonster
#+BEGIN_SRC js

function  allIndxTypeMonster (arr, val )  {

   let indexes = [];

    for(let index = 0; index < arr.length; index++)
        if (arr[index].type === val)
            indexes.push(index);
    
    return indexes;

}
#+END_SRC


** monsterinfocreatedom


#+NAME:  monsterinfocreatedom
#+BEGIN_SRC js

function monsterInfoCreateDOM () {
 console.log("monsterInfoCreateDOM");

 let monstersIndex  = allIndxTypeMonster(worldData, "monster");
 console.log("monsterInfoCreateDOM", monstersIndex  );

 monstersIndex.forEach( index => {

  let monster = worldData[index];

  let monsterTable   = document.getElementById("monsterTable");
  let monsterDOM     = document.getElementById(monster.id);

  let row = document.createElement('tr');
  let monsterId   = document.createElement('td');
  let monsterPosX = document.createElement('td');
  let monsterPosY = document.createElement('td');
  let monsterHP   = document.createElement('td');

  monsterId.id    = `${monster.id}ID`;  
  monsterPosX.id  = `${monster.id}X`;
  monsterPosY.id  = `${monster.id}Y`;
  monsterHP.id    = `${monster.id}HP`; 
 
  row.id = monster.id;
 
  row.appendChild(monsterId); 
  row.appendChild(monsterPosX); 
  row.appendChild(monsterPosY); 
  row.appendChild(monsterHP); 
 
  monsterId.textContent   = monster.id; 
  monsterPosX.textContent = monster.pos.x ;
  monsterPosY.textContent = monster.pos.y;
  monsterHP.textContent   = monster.HP;
   
  monsterTable.appendChild(row);

 });
}


#+END_SRC


** monsterinfoupdate
  

#+NAME:   monsterinfoupdate 
#+BEGIN_SRC js
function monsterInfoUpdate()  {
 console.log("monsterinfoUpdate");
   
 let monstersIndex  = allIndxTypeMonster(worldData, "monster");

 monstersIndex.forEach( index => {

  let monster = worldData[index];
  let monsterTable   = document.getElementById("monsterTable");
  let monsterDOM     = document.getElementById(monster.id);


  let tdId = document.getElementById(`${monster.id}ID`);
  let tdX  = document.getElementById(`${monster.id}X`);
  let tdY  = document.getElementById(`${monster.id}Y`);
  let tdHP = document.getElementById(`${monster.id}HP`);

  tdId.textContent    = monster.id; 
  tdX.textContent     = monster.pos.x ;
  tdY.textContent     = monster.pos.y;
  tdHP.textContent    = monster.HP;
 
  });
}
#+END_SRC


** monsterinforemove

#+NAME: monsterinforemove  
#+BEGIN_SRC js
function monsterInfoRemove(removeMonster) {
  let monsterId = removeMonster.id;
  let monsterToRemove = document.getElementById(monsterId); 

  monsterToRemove.remove();
}
#+END_SRC




** createmonsters

#+NAME: createmonsters
#+BEGIN_SRC js
function createMonsters(thisManyMonsters) {
    let min = 2;
    let max = 29;
    let monsters = [];
    let y = randomY([],thisManyMonsters);

    for (let i = 0; i < thisManyMonsters; i++) {
     let x = Math.floor(Math.random() * (max - min) + min);
      monsters.push(
	Object.assign(
	  {},
	  objects.monster,
	  { id: "monster" + i },
	  { pos: { x: x, y: y[i] } }
	)
      );
    };
    return monsters;
 }
#+END_SRC


** randomy
#+NAME: randomy
#+BEGIN_SRC js
function randomY(arr, thisManyMonsters ) {
    let min = 9;
    let max = 29;
    let y = arr;

    while (y.length < thisManyMonsters) {
      let n = Math.floor(Math.random() * (max - min) + min);
      if (!y.includes(n)) {
       	y.push( n);
      } else {
        randomY(y, y.length);
      }
    }

     return y;
}
#+END_SRC


** drawMap

#+NAME: drawMap
#+BEGIN_SRC js 
function drawMap (){
    ctx.clearRect(0, 0, w, h);
    map.forEach(function(row,i){
	row.forEach(function(tile,j){

	 if(tile != 0) {
	    let index = worldData.findIndex(ele => ele.id === tile);
	    let color = worldData[index].color;
	    ctx.fillStyle = color;
	    drawTile(j,i);
	 }

	});});
}
#+END_SRC    




** drawTile
#+NAME: drawTile
#+BEGIN_SRC js
function drawTile (x,y){
  ctx.fillRect(
    x * tileSize, y * tileSize,
    tileSize, tileSize
  );
}
#+END_SRC





** main

#+NAME: main
#+BEGIN_SRC js :noweb yes  :tangle  ~/Desktop/roguelike/src/index.js :cache yes

<<canvas>>

let w = 400;
let h = 400;
let tileSize = 13;




/******************************************************************************* 

    _____  _     ___________  ___   _     
   |  __ \| |   |  _  | ___ \/ _ \ | |    
   | |  \/| |   | | | | |_/ / /_\ \| |    
   | | __ | |   | | | | ___ \  _  || |    
   | |_\ \| |___\ \_/ / |_/ / | | || |____
    \____/\_____/\___/\____/\_| |_/\_____/


********************************************************************************/

<<worldData>>

<<nextattack>>

<<objects>>


<<map>>



/******************************************************************************* 


    _ __  _ __ ___   __ _ _ __ __ _ _ __ ___  
   | '_ \| '__/ _ \ / _` | '__/ _` | '_ ` _ \ 
   | |_) | | | (_) | (_| | | | (_| | | | | | |
   | .__/|_|  \___/ \__, |_|  \__,_|_| |_| |_|
   | |               __/ |                    
   |_|              |___/     


********************************************************************************/
<<fsm>> 

<<interface>>

<<inputhandler>>

<<collisiondetection>>

<<updater>>

<<drawMap>>

<<drawTile>>


/******************************************************************************* 


     __                  _   _                 
    / _|                | | (_)                
   | |_ _   _ _ __   ___| |_ _  ___  _ __  ___ 
   |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
   | | | |_| | | | | (__| |_| | (_) | | | \__ \
   |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/


********************************************************************************/

<<playerinfo>>

<<createmonsters>>

<<monsterinfocreatedom>>

<<monsterinfoupdate>>

<<monsterinforemove>>

<<move>>

<<attackenemy>>

<<isalive>>

<<differencearray>>

<<allindxtypemonster>>

<<randomy>>

<<start>>



/*
    _____ _____ ___  ______ _____ 
   /  ___|_   _/ _ \ | ___ \_   _|
   \ `--.  | |/ /_\ \| |_/ / | |  
    `--. \ | ||  _  ||    /  | |  
   /\__/ / | || | | || |\ \  | |  
   \____/  \_/\_| |_/\_| \_| \_/  
*/                              

fsmService.start();

start();

#+END_SRC


* CHECK 

#+BEGIN_SRC sh :dir ./src/
jshint index.js;
echo '';
#+END_SRC


* prettier

#+BEGIN_SRC  sh :exports none  :dir ~/Desktop/roguelike 
npm run prettier;
#+END_SRC

#+RESULTS:
: 
: > roguelike@1.0.0 prettier /home/erretres/Desktop/roguelike
: > gulp prettier
: 
: [13:59:16] Using gulpfile ~/Desktop/roguelike/gulpfile.js
: [13:59:16] Starting 'prettier'...
: [13:59:16] Finished 'prettier' after 478 ms



 

